// Globally track the order of the slots
let slotOrder = [];
// Define 'container' at the top of your script to make it globally accessible
const container = document.getElementById('shortcutList');

const markTabButton = document.getElementById('markTabButton');

// Utility function for development mode logging

// Utility function for development mode logging
function debugLog(message, level = 'log') {
    if (isDevelopmentMode()) {
        console[level](message);
    }
}

// Check if the extension is in development mode
function isDevelopmentMode() {
    return !('update_url' in chrome.runtime.getManifest());
}

// ============
// Initialization
// ============

function initializePopup() {
    getCurrentTabUrl();
    updateShortcutList();
    setupEventListeners();
}

/**
 * Adds event listeners when the DOM content is loaded.
 */
document.addEventListener('DOMContentLoaded', initializePopup);
// =================
// UI Update Functions
// =================
function updateShortcutList() {
    try {
        chrome.storage.sync.get(['shortcuts'], function (result) {
            const shortcuts = result.shortcuts || {};
            container.innerHTML = ''; // Clear existing list
            slotOrder = []; // Reset slot order tracking
            Object.keys(shortcuts).forEach(slot => {
                createShortcutItem(slot, shortcuts[slot]);
            });
            setupDragAndDrop();
            selectFirstEmptySlot();  // Ensure the dropdown is updated after list refresh
        });
    } catch (error) {
        debugLog(error, 'error');
    }
}

function createShortcutItem(slot, shortcut) {
    let item = document.createElement('div');
    item.setAttribute('draggable', true);
    item.setAttribute('id', `shortcut-${slot}`);
    item.setAttribute('data-slot', slot);
    item.classList.add('shortcut-item');

    // Include a drag handle icon
    const dragHandle = document.createElement('span');
    dragHandle.classList.add('drag-handle');
    dragHandle.innerHTML = '&#9776;'; // Using the HTML entity for the "hamburger" icon

    item.appendChild(dragHandle);
    // Set the inner HTML for the item's content
    let itemContent = document.createElement('span');
    itemContent.innerHTML = `
                Ctrl+Shift+${slot} 
                <a href="${shortcut.url}" target="_blank" title="${shortcut.title}">
                    ${new URL(shortcut.url).hostname}
                </a>
            `;
    item.appendChild(itemContent);
    // Create remove button
    let removeButton = document.createElement('button');
    removeButton.textContent = 'X';
    removeButton.classList.add('remove-button');
    // Add event listener to the remove button
    removeButton.addEventListener('click', function () {
        removeShortcut(slot);
    });

    // Append the remove button to the item
    item.appendChild(removeButton);
    shortcutList.appendChild(item);
}

// ===============
// Event Handlers
function handleMarkTabClick() {
    const slotSelect = document.getElementById('slotSelect');
    const slot = slotSelect.value;
    const url = document.getElementById('urlDisplay').value;
    const title = document.getElementById('titleDisplay').textContent; // Assume you have an element to display the title
    try {
        // Check for duplicate URLs before adding a new shortcut
        chrome.storage.sync.get(['shortcuts'], function (result) {
            let shortcuts = result.shortcuts || {};
            let isDuplicate = Object.values(shortcuts).some(shortcut => shortcut.url === url);

            if (isDuplicate) {
                alert("This URL is already assigned to a shortcut.");
                return;
            }

            addShortcut(slot, url, title); // Add the shortcut if it's not a duplicate
        });
    } catch (error) {
        debugLog(error, 'error');
    }
}

// ===============
function setupEventListeners() {
    // Set focus on the "Mark This Tab" button
    markTabButton.focus();
    markTabButton.addEventListener('click', handleMarkTabClick);
}

// ===============
// Drag and Drop
// ===============
function setupDragAndDrop() {
    const draggables = container.querySelectorAll('.shortcut-item');

    draggables.forEach(draggable => {
        draggable.addEventListener('dragstart', handleDragStart);
        draggable.addEventListener('dragend', handleDragEnd);
    });

    container.addEventListener('dragover', handleDragOver);
    container.addEventListener('drop', handleDrop);
}

function handleDragStart(e) {
    e.target.classList.add('dragging');
    e.dataTransfer.setData('text/plain', e.target.id);
}

function handleDragEnd(e) {
    e.target.classList.remove('dragging');
}

function handleDragOver(e) {
    e.preventDefault();
    const afterElement = getDragAfterElement(container, e.clientY);
    const draggable = document.querySelector('.dragging');
    if (afterElement == null) {
        container.appendChild(draggable);
    } else {
        container.insertBefore(draggable, afterElement);
    }
}

function handleDrop(e) {
    e.preventDefault();
    const id = e.dataTransfer.getData('text/plain');
    const draggable = document.getElementById(id);
    const afterElement = getDragAfterElement(container, e.clientY);
    const oldIndex = slotOrder.indexOf(id);
    let newIndex = afterElement ? slotOrder.indexOf(afterElement.id) : slotOrder.length;

    if (newIndex >= slotOrder.length) {
        newIndex = slotOrder.length - 1;
    }

    slotOrder.splice(oldIndex, 1); // Remove the item from the old position
    slotOrder.splice(newIndex, 0, id); // Insert the item at the new position

    updateShortcutsOrder(); // Update the storage with the new order
}

function updateShortcutsOrder() {
    function updateShortcutsOrder() {
        let updatedOrder = {};  // Declare updatedOrder outside the try block to increase its scope

        try {
            // Fetch the current shortcuts
            // Logic to update the slot order based on current DOM state after drag-and-drop
            container.querySelectorAll('.shortcut-item').forEach((item, index) => {
                const slot = item.dataset.slot;
                updatedOrder[index] = {...slotOrder[slot]}; // Assuming slotOrder is an object with slot keys
            });
        } catch (error) {
            debugLog(`Error fetching/reordering shortcuts order: ${error}`, "error");
            return; // If there's an error, return early
        }

        try {
            // Save the reordered shortcuts
            chrome.storage.sync.set({shortcuts: updatedOrder}, function () {
                updateShortcutList(); // Redisplay the shortcuts with the new order
            });
        } catch (error) {
            debugLog(`Error updating shortcuts order: ${error}`, "error");
        }
    }
}

function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.shortcut-item:not(.dragging)')];

    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
            return {offset: offset, element: child};
        } else {
            return closest;
        }
    }, {offset: Number.NEGATIVE_INFINITY}).element;
}

// =============
// Utility Functions
// =============
/**
 * Removes the shortcut at the specified slot.
 * @param {number} slot - The slot of the shortcut to be removed.
 */
function removeShortcut(slot) {
    try {
        chrome.storage.sync.get(['shortcuts'], function (result) {
            const shortcuts = result.shortcuts || {};
            if (shortcuts[slot]) {
                delete shortcuts[slot]; // Remove the shortcut from the object
                chrome.storage.sync.set({shortcuts}, function () {
                    updateShortcutList(); // Refresh the list of shortcuts
                    selectFirstEmptySlot(); // Select the first empty slot after removal
                });
            }
        });
    } catch (error) {
        debugLog(`Error removing shortcut: ${error}`, "error");
    }
}

/**
 * Select the first empty slot in the dropdown and update the dropdown options based on the available slots in the chrome storage.
 */
function selectFirstEmptySlot() {
    try {
        chrome.storage.sync.get(['shortcuts'], function (result) {
            const shortcuts = result.shortcuts || {};
            const slotSelect = document.getElementById('slotSelect');
            let emptySlots = 0;

            // Reset the dropdown
            slotSelect.innerHTML = '';

            // Populate dropdown with all slots
            for (let i = 0; i < 3; i++) { // Assuming you have 3 slots
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `Slot ${i} (Ctrl + Shift + ${i})`;
                slotSelect.appendChild(option);

                // Count empty slots
                if (!shortcuts.hasOwnProperty(i.toString())) {
                    emptySlots++;
                }
            }

            // Update the dropdown based on the available slots
            if (emptySlots === 0) {
                // All slots are full, show the corresponding message and disable the button
                slotSelect.innerHTML = ''; // Clear the dropdown
                const option = document.createElement('option');
                option.textContent = "All slots are full";
                slotSelect.appendChild(option);
                slotSelect.disabled = true; // Disable the dropdown
                markTabButton.disabled = true; // Disable the "Mark This Tab" button
            } else {
                // There are empty slots, enable the dropdown and update the options
                slotSelect.disabled = false; // Ensure the dropdown is enabled
                markTabButton.disabled = false; // Ensure the button is enabled
                // Set the dropdown to the first available slot
                for (let i = 0; i < 3; i++) {
                    if (!shortcuts.hasOwnProperty(i.toString())) {
                        slotSelect.value = i.toString();
                        break;
                    }
                }
            }
        });

    } catch (error) {
        debugLog(`Error selecting first empty slot: ${error}`, "error");
    }
}

/**
 * Retrieves the URL and title of the currently active tab and displays them on the webpage.
 */
function getCurrentTabUrl() {
    // Query the active tab in the current window
    chrome.tabs.query({active: true, currentWindow: true}, function (tabs) {
        // Get the current tab
        const currentTab = tabs[0];
        // Display the URL
        document.getElementById('urlDisplay').value = currentTab.url;
        // Display the title
        document.getElementById('titleDisplay').textContent = currentTab.title;
    });
}

/**
 * Adds a shortcut to the storage and refreshes the list of shortcuts.
 * @param {string} slot - The slot to save the shortcut to.
 * @param {string} url - The URL of the tab to save.
 * @param {string} title - The title of the tab to save.
 */
function addShortcut(slot, url, title) {
    try {
        // Get the existing shortcuts from storage or initialize an empty object
        chrome.storage.sync.get(['shortcuts'], function (result) {
            const shortcuts = result.shortcuts || {};

            // Add the new shortcut to the shortcuts object
            shortcuts[slot] = {url: url, title: title}; // Storing an object, not just a string

            // Save the updated shortcuts object to storage
            chrome.storage.sync.set({shortcuts}, function () {
                debugLog(`Shortcut saved for slot ${slot}.`);

                // Refresh the list of shortcuts
                updateShortcutList();
            });
        });
    } catch (error) {
        debugLog(`Error adding shortcut: ${error}`, "error");
    }
}
